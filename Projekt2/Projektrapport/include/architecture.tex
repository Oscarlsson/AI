\chapter{Architecture}
The parser and the planner were implemented in Haskell. The parser interpreted
what blocks the sentence referred to and the planner found a plan of how to
move these blocks to reach the goal state determined by the parser. 

\section{Programs and tools}
Haskell was used to implement the parser and the planner. The predefined grammar was
written in GF and the interface used CGI and JavaScript as GUI. A Python script was
used to handle the communication between the Haskell files and the JavaScripts.
\\\\
The planner was implemented using a standard library priority queue \citep{psq_url}. 

\section{Backend structure}
The parser and the planner shared a number of common functions and structures,
which were defined in two separate modules found in Appendix B.1 and Appendix
B.2. These modules defined how to create a representation of a world from the
given sentence and functions such as to check whether a certain block is
relative to another block or not. 

\section{Parser}
\label{sec:parser}
The sentence was first modified by removing special characters. Also, all characters were changed to lowercase so it
could be given and parsed by the GF grammar. To be able to use pattern matching
on the generated output from the GF parser, the GF grammar was translated into
Haskell data types, which were automatically generated (See Appendix B.7). From
this grammar an abstract syntax was generated for the input to be used for
pattern matching. If the input was ambiguous, several parse trees were
generated and passed to the planner. \\\\
For each parse tree, the tree was translated to an output which was given to
the planner. Since some parse trees could refer to, for example, non existing
objects in the world the parser used an Error Monad to tell if the given tree
was OK or not. \\\\
The output to the planner (fully stated in Appendix B.5) consists of three parts:
\begin{itemize}
\item An action to do ($Move$, $Put$ or $Take$)
\item A list of blocks to be moved
\item A location where to move the blocks, which consists of an reference
        ($Above$, $Beside$, $Inside$, $LeftOf$, $OnTop$, $RightOf$ or $Under$)
        and a list of blocks which the reference refers to or $Floor$ and a
        list of stack indexes where the stack is empty.
\end{itemize}
The output differed depending on which action to do. E.g. the action $Take$ did
not have a location and the action $Put$ would only have the block in holding
as the list of blocks to be moved. If holding is $null$, $Put$ would do nothing
since it assumes that there is a block in holding in contrast to the action
$Move$.\\\\
The parser would always find out if the blocks the input referred to exists and
if not, give an error. All laws of physics except where the robot is allowed to
drop blocks is preserved within the parser. It would be impossible to take a
block left of or right of all blocks, since this refers to the block itself.
And it would not be allowed to take the floor or put something inside a block
that is not a box. All blocks must also be above the floor. If any of these
laws were violated, an error was returned.
 \\\\
If a block should be put left of or right of several blocks, the parser returns
the leftmost or rightmost block as a reference block. 

\section{Planner}
The planner uses the $A^*$ similar to Algorithm \ref{algorithm:astar}. The
algorithm works as mentioned by maintaining a priority queue of possible
successor nodes in the state space of the search problem. Each node represents a
state defined by the blocks in the world and the holding attribute. In addition,
a node keeps a history, i.e. a sequence of instructions that lead up to the
state. The priority for each node is defined by the length of the history $g(n)$ plus
its heuristic function value $h(n)$ as defined in Equation \ref{Eq:astar}. The next node to be expanded in each step is
always the node with the shortest combination of history length and heuristic
function value. This ensures that an expanded node, i.e. the popped node of the
queue, always have its shortest path associated with it under the premise that
the heuristic function never overestimates any node. Thus, the algorithm
terminates when it pops a node that is in a finished state. 

The successor function adds to the queue every possible node that can be reached
by applying any legal instruction, except those that have previously been
expanded. The successor nodes are not evaluated for being finished since this
would yield premature termination as explained above.

A problem is regarded as unsolvable if a configurable maximum of 1000 nodes are
expanded before finding a finished state. This case covers both impossible
problems and those problems that the algorithm fails to solve. It was not
prioritized during the project to distinguish between the two, since many
different cases would need to be implemented for the algorithm to be able to
identify the type of goals that are impossible. 

\begin{algorithm}[h!]
 \SetAlgoLined
 \KwData{TimeoutInt, World, Goal}
 \KwResult{History}
 Initialize priority queue $PQ$ with world, empty history and value 0\;
 $Seen \leftarrow empty$\;
 \While{not timeout}{
   $World$, $History$ $\leftarrow$ pop $PQ$\;
   \If {$World == Goal$}{
    break\;
   }
   $Seen \leftarrow World + Seen$\; 
   $Succ \leftarrow$ successors of $World$ not in $Seen$\;
   $PQ' \leftarrow$ add $Succ$\;
 }
 \Return $History$
 \caption{A*}
 \label{algorithm:astar}
\end{algorithm} 

\subsection{Scope and constraints}

This section discusses the scope and constraints of the planner in terms of the
decisions that were made regarding how to interpret references to blocks and
locations.

\subsubsection{Blocks to move} 
\label{sec:blockstomove}
The goal object is defined partly by a list of blocks to move, from here on
referred to as objects. The initial parse tree may have referred to these
objects as either (1) \textit{any/a(n)}, (2) \textit{the} or (3) \textit{all}.
The natural response to these are to (1) move the block that yields the shortest
path, (2) question the user if there is ambiguity and (3) move all matching
blocks.

During the project, we prioritized and solved for the possibility for our
algorithm to handle multiple objects, and the planner does not distinguish
between the three cases above; i.e. if several objects are referenced, all of
them need to be moved to the requested location. This was due to the fact that
the code can easily be extended by adding various checks in a procedure that
handles the cases above, as long as the general case of moving several objects
has been implemented.

\subsubsection{Blocks in location reference}

The location reference of the goal object definition (e.g. \textit{LeftOf},
\textit{OnTop} etc. as explained in section \ref{location:parser}) generally
refers to a list of blocks, from here on referred to as targets. The parse tree
may, just as for objects in section \ref{sec:blockstomove}, refer to these
targets by \textit{any/a(n), the} or \textit{all}, with the same natural ways to
handle them as mentioned previously. The goal object maintains a list of
matching targets, and it has not been prioritized to distinguish between the
cases or handling any other than the first element in the list of matching
targets. The code can easily be extended to handle not just one, but any number
of targets in an appropriate way.

%To make sure of that a solution is found a world must satisfy a number of logical
%constraints. This is generated from an interpretation of what the user has
%written. This interpretation comes from the parsing of the natural language but 
%also choices from what a given parse tree actually means. This logical
%constraints differ for different parse trees.

-----OLD STUFF NOT REWRITTEN BELOW-------

Issues in current scope
    Rearranging blocks in space other than that of which the 
    heuristic function handles.
        Examples

The laws of physics in the world are handled by comparison functions. A pyramid
and a ball are always smaller than every other object. In this way it is never
possible to put anything on a ball or pyramid. 
\\\\
The heuristic assumes that that there are infinitely many free spaces in the
world where one can but a block. From this follows that one can always move a
free block in two steps. 
%Varje nod är en värld och en historia som består av en sekvens av
%instruktioner.  Noderna sparas i en prioritetskö och två lika dana värdar
%sparas aldrig mer än en gång. 

%Om vi poppar en värld ur prioritetskön som också
%uppfyller finished så är vi färdiga till skillnad från om vi hade hittat en
%succsessor som var finishid för då kan vi inte garantera optimalitet. Detta på
%grund utav att vi måste ta hänsyn till heuristiken. 

%För att veta om vi är färdiga så måste världen uppfylla ett antal logiska
%satser som vi generar utifrån vår tolkning av den meningen som användaren
%anger. Dessa logiska satser skiljer mellan olika parseträd.

%Vi har en timeout på $A^*$ som innebär att vi avbryter om det visar sig att
%algoritmen tar för lång tid. Oftast på grund utav att det inte finns någon
%lösning. 

%Fysiken sköts av en jämnförelseoperator på block. En pyramid eller en boll är alltid
%mindre än allt annat och vi kan bara lägga mindre block på större block. På så
%sätt är det aldrig möjligt att lägga någonting på en boll eller en pyramid.  


%Heuristikfunktionen antar att vi har ett oändligt antal liga platser i världen.
%Dvs vi antar alltid att vi kan flytta ett block inom ramen av två steg. 
%* goal, finished \\


%* heuristic function\\


%* A*, nodes and edges, timeout\\


%* instructions, valid, comparator\\


%* pseudo code A*\\\\

%Successors på en värld returnerar alla möjliga världar man kan komma till genom
%att göra en tillåten instruktion. Add räknar ut f(n) på varje värld
\section{Parser and Planner}
The main idea with the implementation of the parser and the planner was that the
parser should take care of the interpretation of a sentence and the planner
should take this interpretation and perform the actions which should lead to a
solution. However there are cases when the input string may lead to
ambiguous output by the parser. For example the sentence ''Move all blocks inside a box on top
of the red square.'' makes it possible to move blocks from different boxes. One could
also choose to interpret the sentence as to move all blocks from every box. Even
further there may be more than one red square in the world. Instead of asking 
attendant questions to the user the idea was to send all possible meanings of
the sentence to the planner. The planner should output one and only one plan as simple as
possible from all the possible interpretations. 
\\\\
The parser takes care of a lot of impossible sentences such as ''Take the
floor''. Some sentences will however pass the parser since they do not seem
directly impossible. For example ''Move all blocks inside a box on top of a
square''. This may be impossible due to the laws of physics in the world. Say
for instance that there is only one square in the world and this square is
smaller than some block in a box, then there is no possible solution because it
is impossible to put a bigger block on top of a smaller block. The idea here
was that the planner should realize this and take an other interpretation if
several interpretations where generated by the parser and otherwise fail with
some informative error. For now only a time out message is delivered by the
planner.           



