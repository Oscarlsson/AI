\chapter{Architecture}
The parser and the planner were implemented in Haskell. The parser interpreted
what blocks the sentence referred to and the planner found a plan of how to
move these blocks to reach the goal state determined by the parser. 

\section{Programs and tools}
Haskell was used to implement the parser and the planner. The predefined grammar was
written in GF and the interface used CGI and JavaScript as GUI. A Python script was
used to handle the communication between the Haskell files and the JavaScripts.
\\\\
The planner was implemented using a standard library priority queue \citep{psq_url}. 

\section{Backend structure}
The parser and the planner shared a number of common functions and structures,
which were defined in two separate modules found in Appendix B.1 and Appendix
B.2. These modules defined how to create a representation of a world from the
given sentence and functions such as to check whether a certain block is
relative to another block or not. 

\section{Parser}
\label{sec:parser}
The sentence was first modified by removing special characters. Also, all characters were changed to lowercase so it
could be given and parsed by the GF grammar. To be able to use pattern matching
on the generated output from the GF parser, the GF grammar was translated into
Haskell data types, which were automatically generated (See Appendix B.7). From
this grammar an abstract syntax was generated for the input to be used for
pattern matching. If the input was ambiguous, several parse trees were
generated and passed to the planner. \\\\
For each parse tree, the tree was translated to an output which was given to
the planner. Since some parse trees could refer to, for example, non existing
objects in the world the parser used an Error Monad to tell if the given tree
was OK or not. \\\\
The output to the planner (fully stated in Appendix B.5) consists of three parts:
\begin{itemize}
\item An action to do ($Move$, $Put$ or $Take$)
\item A list of blocks to be moved
\item A location where to move the blocks, which consists of an reference
        ($Above$, $Beside$, $Inside$, $LeftOf$, $OnTop$, $RightOf$ or $Under$)
        and a list of blocks which the reference refers to or $Floor$ and a
        list of stack indexes where the stack is empty.
\end{itemize}
The output differed depending on which action to do. E.g. the action $Take$ did
not have a location and the action $Put$ would only have the block in holding
as the list of blocks to be moved. If holding is $null$, $Put$ would do nothing
since it assumes that there is a block in holding in contrast to the action
$Move$.\\\\
The parser would always find out if the blocks the input referred to exists and
if not, give an error. All laws of physics except where the robot is allowed to
drop blocks is preserved within the parser. It would be impossible to take a
block left of or right of all blocks, since this refers to the block itself.
And it would not be allowed to take the floor or put something inside a block
that is not a box. All blocks must also be above the floor. If any of these
laws were violated, an error was returned.
 \\\\
If a block should be put left of or right of several blocks, the parser returns
the leftmost or rightmost block as a reference block. 

\section{Planner} 
The planner used the $A^*$-algorithm similar to Algorithm \ref{algorithm:astar}.
The algorithm worked as mentioned by maintaining a priority queue of possible
successor nodes in the state space of the search problem. Each node represented a
state defined by the blocks in the world and the holding attribute. In addition,
a node kept a history, i.e. a sequence of instructions that lead up to the
state. The priority for each node was defined by the length of the history $g(n)$
plus its heuristic function value $h(n)$ as defined in Equation \ref{Eq:astar}.
The next node to be expanded in each step is always the node with the shortest
combination of history length and heuristic function value $f(n) = g(n) + h(n)$.
This ensured that an expanded node, i.e. the popped node of the queue, always
have the shortest possible path associated with it under the premise that the
heuristic function never overestimates any node. Thus, the algorithm terminates
when it pops a node that is in a finished state. 
\\\\\\\\\\\\\\
The successor function adds to the queue every possible node that can be reached
by applying any legal instruction, except for those that have previously been
expanded (visited). The successor nodes should not be checked for being finished
since this would yield premature termination as explained above. Legal moves
include the laws of physics which were handled by comparison functions
respecting the width of objects and also that a pyramid and a ball are always
smaller than any other object. In this way it was easy to say all blocks must be
supported by larger or equally sized blocks.
\\\\
A problem was regarded as unsolvable if a (configurable) maximum of 1000 nodes
are expanded before finding a finished state. This case covers both impossible
problems and those problems that the algorithm fails to solve. It was not
prioritized during the project to distinguish between the two, since many
different cases would need to be implemented for the algorithm to be able to
identify the type of goals that are impossible. \\
\begin{algorithm}[h!]
 \SetAlgoLined
 \KwData{TimeoutInt, World, Goal}
 \KwResult{History}
 Initialize priority queue $PQ$ with world, empty history and value 0\;
 $Seen \leftarrow empty$\;
 \While{not timeout}{
   $World$, $History$ $\leftarrow$ pop $PQ$\;
   \If {$World == Goal$}{
    break\;
   }
   $Seen \leftarrow World + Seen$\; 
   $Succ \leftarrow$ successors of $World$ not in $Seen$\;
   $PQ' \leftarrow$ add $Succ$\;
 }
 \Return $History$
 \caption{A*}
 \label{algorithm:astar}
\end{algorithm} 

\subsection{Heuristic function}
The task of a heuristic function is to use rules of thumb to estimate the
remaining path length to the goal. For this proejct, there was no definite
answer to such a method, since that would imply solving the actual problem.
Instead, it was possible to define a lower bound in terms of the number of moves
required to clear all blocks obstructing the path between any block's start and
final position. Simply moving a block requires \textit{at least}\footnote{Moving
a block may require moving other blocks first, since there may be no other legal
positions for it to move to.} two moves, a pick and a drop. In addition, all
misplaced blocks need to be moved which also contributed to the path length.  
\\
The performance of the $A*$-algorithm depends heavily on the heuristic function.
If it is constant, a breadth first search is performed, which is clearly
impractical since the Shrdlite world usually has at least 5-10 valid moves per
turn, and around 10 moves are a normal plan length, which easly puts the number
of node evaluations in the order of millions. 
\\\\
Due to its large impact, the heuristic function also adjusted its value based on
which block is being held; a held block that is supposed to be moved has a $+1$
(instead of $+2$ as it would be on the ground), and holding a neutral block had
a $+1$ contribution since it \textit{at least} has to be dropped. In addition,
blocks to be moved (and their obstructing blocks) were not counted if they are
already in the final position.

\subsubsection{Issues}
The rules explained in the previous section were designed to handle cases where
a number of blocks lie on top of each of the blocks that the user has referred
to. The heuristic function was defined so that the planner prioritizes to set
these blocks aside as fast as possible.
\\\\
A possible issue with this method arises when there is not much free space
around the referenced blocks. If there is no free space to put the obstructing
blocks, and rearrangements are required, the heuristic function has no way to
distinguish between different sets of such rearrangements. This can be compared
to a Tower of Hanoi \footnote{Tower of Hanoi -
\url{http://en.wikipedia.org/wiki/Tower_of_Hanoi}} problem where a high amount of
moves has to be made to utilize the little amount of available space. Since the
search tree grows quickly as mentioned previously, it only requires a slight
shortage of space to cripple the algorithm, but it is a rare event in the
somewhat sparse world that was worked on during this project.

\subsection{Scope and constraints}
This section discusses the scope and constraints of the planner in terms of the
decisions that were made regarding how to interpret references to blocks and
locations.

\subsubsection{Blocks to move} 
\label{sec:blockstomove}
The goal object is defined partly by a list of blocks to move, from here on
referred to as objects. The initial parse tree may have referred to these
objects as either (1) \textit{any/a(n)}, (2) \textit{the} or (3) \textit{all}.
The natural response to these are to (1) move the block that yields the shortest
path, (2) question the user if there is ambiguity and (3) move all matching
blocks.
\\\\\\\\
During the project, we prioritized and solved for the possibility for our
algorithm to handle multiple objects, and the planner does not distinguish
between the three cases above; i.e. if several objects are referenced, all of
them need to be moved to the requested location. This was due to the fact that
the code can easily be extended by adding various checks in a procedure that
handles the cases above, as long as the general case of moving several objects
has been implemented.

\subsubsection{Blocks in location reference}
The location reference of the goal object definition (e.g. \textit{LeftOf},
\textit{OnTop} etc. as explained in section \ref{sec:parser}) generally refers
to a list of blocks, from here on referred to as targets. The parse tree may,
just as for objects in section \ref{sec:blockstomove}, refer to these targets by
\textit{any/a(n), the} or \textit{all}, with the same natural ways to handle
them as mentioned previously. The goal object maintains a list of matching
targets, and it was not prioritized to distinguish between the cases or handling
any other than the first element in the list of matching targets. The code can
easily be extended to handle not just one, but any number of targets in an
appropriate way.

\section{Parser and Planner}
The main idea with the implementation of the parser and the planner was that the
parser should take care of the interpretation of a sentence and the planner
should take this interpretation and perform the actions which should lead to a
solution. However there are cases when the input string may lead to ambiguous
output by the parser. For example the sentence ''Move all blocks inside a box on
top of the red square.'' makes it possible to move blocks from different boxes.
One could also choose to interpret the sentence as to move all blocks from every
box. Even further there may be more than one red square in the world. Instead of
asking attendant questions to the user the idea was to send all possible
meanings of the sentence to the planner. The planner should output one and only
one plan as simple as possible from all the possible interpretations. 
\\\\
The parser takes care of a lot of impossible sentences such as ''Take the
floor''. Some sentences will however pass the parser since they do not seem
directly impossible. For example ''Move all blocks inside a box on top of a
square''. This may be impossible due to the laws of physics in the world. Say
for instance that there is only one square in the world and this square is
smaller than some block in a box, then there is no possible solution because it
is impossible to put a bigger block on top of a smaller block. The idea here was
that the planner should realize this and take an other interpretation if several
interpretations where generated by the parser and otherwise fail with some
informative error. For now only a time out message is delivered by the planner.
