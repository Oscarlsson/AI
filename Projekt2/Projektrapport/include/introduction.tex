\chapter{Introduction}
This project was about planning in a virtual world. Planning is about devising a plan of actions to reach a specific goal \citep{planning_ai}. There is several different methods that can be used for the planning part, such as building a search graph or using logic. 
Planning could be used to determine a route, for example schedule flights. In this project, planning was applied using natural language in a dialogue system for a robot. The task was to, depending on the message given, set up a planning and move the blocks in the given world.

\section{Problem description}
The project was about implementing a dialogue system for a robot in a two-dimentional virtual world, where the robot had an arm to pick up and drop blocks in the world. The dialogue system was a written dialogue were the user wrote natural language commands which the system translated to a planning and resulting commands to the robot. The project then had two parts: parse the given input command and to make and perform a planning. The planning should also be efficient. \\\\
A problem in the world was that the blocks had different forms and different sizes and all moves should follow the laws of physics, for example nothing can be put on a ball and small blocks cannot hold bigger blocks. \\\\
Another problem was that natural language commands could be ambiguous and therefore result in several possible plannings.

\section{Theory}
This project is inspired by a Phd project called SHRDLU which also is a dialogue system but more advanced and it operates in a 3D-world. To parse the natural language commands Grammatical Framework were used and the search algorithm A* were use to get a planning. The project operates in the blocks world.

\subsection{SHRDLU}
SHRDLU is a program written by Terry Winograd as a Phd project. SHRDLU is used for understanding natural language by an interactive English dialog between the computer and a user, about a small three-dimentional world of blocks \citep{SHRDLU_url}. The program is able to move various objects in the world, naming collections and answering general questions about the world \citep{SHRDLU_url}. SHRDLU also have a built-in memory and can both remember and discuss its plans and actions.

\subsection{Grammatical Framework}
Grammatical Framework, GF, is a programming language for writing grammars of natural languages. GF is able to parse and generate text in several different languages using a representation that is language-independent \citep{gf_url}. GF can generate both abstract and concrete syntax and is not rescricted to a specific programming language. It is a functional language but it is specialized on grammars \citep{gf_url}. 
GF can easily be included in for example Haskell, Java or JavaScript \citep{gf_url}.

\subsection{The blocks world}
The project is closely related to the blocks world, which is a famous planning domain that consists of a set of cubes on a table \citep{blocksworld_ai}. The blocks can be stacked but only one block can be on top of another. There is also a robot arm to move pick up and move the blocks, which could one pick up one block at a time \citep{blocksworld_ai}. The goal is to build one or more stacks of the blocks, which is specified by which block should be on top of what other blocks \citep{blocksworld_ai}. An example is shown in Figure \ref{fig:blocksworld}.
\begin{figure}[h!]
\centering
\includegraphics[scale = 0.4]{fig/blocksworld.png}
\caption{Example of an initial state and goal state in the blocks world \citep{blocksworld_fig}}
\label{fig:blocksworld}
\end{figure}\\
The most important difference between the blocks world and this project is that in this project the blocks could have several different forms and all moves must follow the laws of physics. The blocks can also be specified by different colors and different sizes.  

\subsection{A*}
A* is a search algorithm which is widely used in pathfinding and graph traversal. A* uses best-first search and evaluates the nodes according to Equation \ref{Eq:astar} \citep{astar_ai}. 
\begin{equation}
f(n) = g(n) + h(n)
\label{Eq:astar}
\end{equation}
where $g(n)$ is the cost to reach the node and $h(n)$ is cost to get from the node to the goal \citep{astar_ai}. This gives that $f(n)$ is the estimated cost of the cheapest solotion through $n$. If the heuristic function $h(n)$ satisfy certain conditions, it could be proven that A* is both complete and optimal \citep{astar_ai}. For A* to be optimal the heuristic function must never overestimate the cost to reach the goal. This gives that $f(n)$ never overrestimates the cost of a solution either. Also the heuristic function must be consistent, which is defined as follows: For every node $n$ and every successor $n'$ generated by an action $a$, the estimated cost fo reaching the goal from $n$ cannot be greather than the step cost of getting to $n'$ plus the estimated cost fo reaching the goal from $n'$ \citep{astar_ai}. This is also described in Equation \ref{Eq:consistent_astar}.
\begin{equation}
h(n) \leq c(n, a, n') + h(n')
\label{Eq:consistent_astar}
\end{equation}
It could also be proved that A* is optimally efficent for any consistent heuristic. This means that no other optimal algorithm is guaranteed to expand fewer nodes than A* \citep{astar_ai}. However, A* is not beneficial for many large-scaled problems since it keeps all generated nodes in memory so it can run out of space before it runs out of time \citep{astar_ai}.\\\\
The time complexity of A* depends on the heuristic function. In the worst case the number of expanded nodes is exponential, but it is polynomial if the search space is a tree.
