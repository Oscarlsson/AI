\chapter{Introduction}
This project was about planning in a virtual world. Planning is about devising a plan of actions to reach a specific goal \citep{planning_ai}. There is several different methods that can be used for the planning part, such as building a search graph or using logic. 
Planning could be used to determine a route, for example schedule flights. In this project, planning was applied using natural language in a dialogue system for a robot. The task was to, depending on the message given, set up a planning and move the blocks in the given world.

\section{Problem description}
The project was about implementing a dialogue system for a robot in a two-dimentional virtual world, where the robot had an arm to pick up and drop blocks in the world. The dialogue system was a written dialogue were the user wrote natural language commands which the system translated to a planning and resulting commands to the robot. The project then had two parts: parse the given input command and to make and perform a planning. The planning should also be efficient. \\\\
A problem in the world was that the blocks had different forms and different sizes and all moves should follow the laws of physics, for example nothing can be put on a ball and small blocks cannot hold bigger blocks. \\\\
Another problem was that natural language commands could be ambiguous and therefore result in several possible plannings.

\section{Theory}
This project is inspired by a Phd project called SHRDLU which also is a dialogue system but more advanced and it operates in a 3D-world. To parse the natural language commands Grammatical Framework were used and the search algorithm A* were use to get a planning. 

\subsection{SHRDLU}
SHRDLU is a program written by Terry Winograd as a Phd project. SHRDLU is used for understanding natural language by an interactive English dialog between the computer and a user, about a small three-dimentional world of blocks \citep{SHRDLU_url}. The program is able to move various objects in the world, naming collections and answering general questions about the world \citep{SHRDLU_url}. SHRDLU also have a built-in memory and can both remember and discuss its plans and actions.

\subsection{Grammatical Framework}
Grammatical Framework, GF, is a programming language for writing grammars of natural languages. GF is able to parse and generate text in several different languages using a representation that is language-independent \citep{gf_url}. GF can generate both abstract and concrete syntax and is not rescricted to a specific programming language. It is a functional language but it is specialized on grammars \citep{gf_url}. 
GF can easily be included in for example Haskell, Java or JavaScript \citep{gf_url}.
\subsection{A*}
A* is a search algorithm which is widely used in pathfinding and graph traversal. A* uses best-first search and evaluates the nodes according to Equation \ref{Eq:astar} \citep{astar_ai}. 
\begin{equation}
f(n) = g(n) + h(n)
\label{Eq:astar}
\end{equation}
where $g(n)$ is the cost to reach the node and $h(n)$ is cost to get from the node to the goal \citep{astar_ai}. This gives that $f(n)$ is the estimated cost of the cheapest solotion through $n$. If the heuristic function $h(n)$ satisfy certain conditions, it could be proven that A* is both complete and optimal \citep{astar_ai}. For A* to be optimal the heuristic function must never overestimate the cost to reach the goal. This gives that $f(n)$ never overrestimates the cost of a solution either. Also the heuristic function must be consistent, which is defined as follows: For every node $n$ and every successor $n'$ generated by an action $a$, the estimated cost fo reaching the goal from $n$ cannot be greather than the step cost of getting to $n'$ plus the estimated cost fo reaching the goal from $n'$ \citep{astar_ai}. This is also described in Equation \ref{Eq:consistent_astar}.
\begin{equation}
h(n) \leq c(n, a, n') + h(n')
\label{Eq:consistent_astar}
\end{equation}
It could also be proved that A* is optimally efficent for any consistent heuristic. This means that no other optimal algorithm is guaranteed to expand fewer nodes than A* \citep{astar_ai}. However, A* is not beneficial for many large-scaled problems since it keeps all generated nodes in memory so it can run out of space before it runs out of time \citep{astar_ai}.\\\\
The time complexity of A* depends on the heuristic function. In the worst case the number of expanded nodes is exponential, but it is polynomial if the search space is a tree.
